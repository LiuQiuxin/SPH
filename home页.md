# vue-cli脚手架初始化项目
## 1、使用命令
        vue create app
## 2、vue-cli脚手架初始化项目的文件夹解析
1. node-modules文件夹：项目的依赖文件夹,里面存储了项目需要的一些库和插件
2. public文件夹：一般用来放置一些静态资源(图片),在webpact对项目进行打包的时候，会将public文件夹下的内容原封不动的打包到dist文件夹下
3. src文件夹(程序员源代码文件夹)：<br/>
    (1)assets文件夹：一般用来放置静态资源文件(一般用于放置多个组件共用的静态资源)，在webpact对项目进行打包时会将assets文件夹当做一个模块，打包在dist文件夹下的js文件夹中<br/>
    (2)components文件夹：一般用于放置非路由组件
4. App.vue：项目中的唯一根组件
5. main.js文件：程序的入口文件，也是整个项目中最先执行的文件
6. gitignore:git的忽略文件，一般不管
7. babel.config.js:与babel相关配置的文件
8. package.json文件：项目的身份证，用于记录项目的名字、项目中用到的依赖、项目如何运行等
9. package-lock.json:缓存性文件

# 项目的其他配置：
## 1、在项目运行的时候，让浏览器自动打开
1. 找到package.json文件，在其配置项scripts中，将server属性的值改成:vue-cli-service serve --open

## 2、eslint校验工具的关闭(可不关闭)
1. 在根目录下创建一个vue.config.js(名字不能更改)文件，在文件中进行配置

        moudle.exports = {
            //关闭eslint
            lintOnSave:false,
        }

## 3、src文件夹简写方式，即给src文件夹配置别名，使用@代替src文件夹
1. 在根目录下创建jsconfig.json(名字不可更改)文件，并填写以下代码

        {
            "compilerOptions":{
                "baseUrl":"./",
                "paths":{
                    "@/*":["src/*"],
                },
            },

            "exclude":["node_modules","dist"],
        }

# 项目路由分析
## 1、项目是上中下结构的，即页面分为了三个部分：头部、中部和底部
## 2、项目中的路由组件
1. Home首页路由组件
2. Search搜索路由组件
3. Login登陆组件
4. Register注册路由组件
## 3、非路由组件
1. Header头部组件
2. Footer底部组件(在首页和搜索页有，在登录页和注册页没有)

# 开发项目的一般流程
1. 书写静态页面
2. 拆分组件
3. 获取服务器的数据动态显示
4. 完成相应的动态业务逻辑
#### 注意事项
1. 创建组件时，组件=组件结构+组件样式+图片资源
2. 项目采用的是less样式，但是浏览器不能识别less样式，需要通过less、less-loader(本项目采用的是版本5)进行处理less,把less样式变为css样式，浏览器才可以识别
# 路由组件的搭建
## 1、pages或views文件夹用于放置路由组件，项目中的路由配置一般放在router文件夹下
## 2、路由组件和非路由组件的区别
1. 组件放置的位置不同：路由组件一般是放在pages或views文件夹中，而非路由组件一般放置在components文件夹中
2. 路由组件一般需要在router文件夹中进行注册(component配置项的值即为组件名)，非路由组件在使用的时候，一般都是以标签的形式使用
## 3、当在入口文件文件main.js中配置了router配置项后，每一个组件(包括路由组件和非路由组件)身上都会有$router和$route属性，其中$router一般用于进行编程式导航(push、replace、back、forward、go等)，$route属性一般用于获取路由信息(跳转路径、query、params等等)

## 4、路由的跳转形式
1. 路由有两种跳转形式：声明式导航(router-link)和编程式导航(push|replace)
2. 声明式导航能做的编程式导航都能做，但是编程式导航除了可以进行路由导航，还可以做一些其他的业务逻辑
3. 两种导航方式的选择：若只想做页面的跳转没有其他的业务逻辑且触发跳转的是a标签使用声明式导航，若除了页面跳转还有其他的业务逻辑需要使用编程式导航
# 路由元信息(meta)的使用
## 1、实现Footer组件的显示与隐藏(v-if和v-show)
1. Footer组件在页面跳转到Home和Search时显示，在页面跳转到登陆和注册时隐藏<br>
        (1)方式1：可以根据组件身上的$route.path属性获取当前的路由信息,通过路由信息判断Footer的显示与隐藏，但是若需要判断的路径很多，该方式就会很繁杂<br>
        (2)方式2：配置路由的时候，可以给路由添加元信息(meta)，在元信息里面设置控制Footer组件显示与隐藏的属性，就可以通过该属性判断路由信息的显示与隐藏，简单易懂
2. 

# 路由传参
## 1、路由传递的参数有两种写法
1. params参数：传递时属于路径当中的一个部分，在配置路由的时候需要占位
2. query参数：不属于路径当中的一部分，类似于ajax中的queryString,配置路由时不需要传递参数
3. this.router属性的属性值是VueRouter类的一个实例，是在入口文件注册路由的时候，给组件实例添加的属性。

# 完成Home首页业务逻辑
## 1、完成三级联动组件
1. 由于三级联动，在Home、Search、Detail组件页面都出现了，所以可以将三级联动组件注册成为一个全局组件，这样可以实现一次注册，多次在项目的不同组件中使用
2. 完成其余静态组件的拆分


# 使用POSTMAN工具测试接口
## 1、如果服务器返回的数据code字段是200，则代表服务器返回数据成功
## 2、在该项目中，所有的接口前缀都有/api字样

# axios二次封装
## 1、为什么要对axios进行二次封装?
1. 为了使用axios的请求拦截器和响应拦截器，所以需要进行二次封装<br>
    (1)添加请求拦截器的目的：在客户端向服务器发送请求之前可以处理一些业务<br>
    (2)添加响应拦截器的目的：在服务器向客户端返回响应数据后，可以处理一些业务
2. 在项目中的api文件夹主要存放了有关axios的文件

# 接口统一管理
## 1、若项目很小，只需要1到两个接口的话，可以直接在组件的生命周期函数中发请求，当组件挂载到页面时获取到数据进行展示
## 2、若项目很大，则需要将接口请求统一管理，便于维护;
## 3、在向接口发送请求的过程中要注意解决跨域问题
1. 本项目的前端部分是本地服务器http://localhost:8080/#/home运行的，而后端接口数据是储存在http://39.98.123.211服务器上的，所以违背了同源策略，产生了跨域问题
2. 本项目采用了代理服务器的方式解决跨域问题

# nprogress进度条的使用
## 1、nprogress是一个用于控制进度条的插件库，当引入项目中时会返回一个对象，对象中的start方法代表进度条开始，done方法代表进度条结束
## 2、要想进度条出现效果，还需要引入其样式，在样式表中还可以根据自己的需求修改进度条的样式

# vuex状态管理仓库
## 1、vuex是vue官方提供的一个插件，用于集中式管理项目中组件共用的数据，并不是全部的项目都要使用vuex，如果项目很小，完全不需要使用vuex,如果项目很大，组件很多，数据很多，数据维护很费劲，就可以使用vuex

# 完成三级联动导航栏的一级分类动态添加背景颜色
## 1、第一种解决方案:自己添加css样式完成
## 2、第二种解决方案：通过自己编写js完成:编写一个控制一级分类背景颜色的样式类，给鼠标移入的元素动态添加该类即可实现

# 演示卡顿现象引入防抖和节流
## 1、理想情况下：即使事件触发非常频繁，但是每一次的触发，回调函数都要去执行
## 2、实际情况下：如果事件触发非常频繁，时间很短，而回调函数内部有计算的话，就很可能出现浏览器卡顿现象。所以为了解决浏览器的卡顿现象，需要采用防抖和节流


# 函数防抖和节流的理解
## 1、防抖:前面的所有触发都会被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发事件，最后一次触发回调函数才会执行
## 2、节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发
## 3、lodash插件实现函数的防抖和节流
1. lodash插件里面封装了函数的防抖和节流业务(闭包+延迟器实现的)
2. lodash插件引入后会向外暴露一个_函数，_函数有一个方法debounce()可以实现回调函数的防抖
        _.debounce();
3. _函数有一个方法throttle()可以实现回调函数的节流
        _.throttle();
4. 简单理解：<br>
    (1)防抖:用户操作很频繁，但是只会执行最后一次操作调用回调函数<br>
    (2)节流:用户操作很频繁，但是把频繁的操作变成了少量的操作，只执行几次回调函数(可以给浏览器有充裕的时间解析代码)
5. 原生的节流防抖是采用闭包+延时器实现的

# 三级联动组件的路由跳转与传递参数
## 1、三级联动导航栏是可以点击的，当点击不同的元素时，Home模块会跳转到Search模块，一级会把用户选中的产品(产品的名字，产品的id)在路由跳转时进行传递
## 2、在本功能中，如果使用声明式导航进行跳转的话容易造成浏览器卡顿，因为声明式导航<router-link>本质上是一个组件，当服务器的数据返回以后，会循环出很多的<router-link>组件实例，而一瞬间创建出如此多的组件实例是很消耗内存的，所以会出现卡顿现象，所以本功能使用编程式导航+事件委派实现路由跳转传参数。使用了事件委派后就可以减少事件的绑定，只需要将事件绑定给三级导航共同的父元素即可。
## 3、利用事件委派+编程式导航有很多优点，但是存在一些问题:<br>
    (1)如何确定点击的是a标签<br>?
    (2)如何获取参数(1、2、3级导航商品的信息)？
    答案:给需要有点击事件的a标签添加自定义属性data-categoryName等，再集合event.target.dataset属性读取标签的自定义属性即可解决上方的问题

# 开发Search模块中的TypeNav商品分类菜单(过渡动画效果)
## 1、过渡动画实现的前提：组件或者元素务必要有v-if或者v-show指令才可以进行过渡

# 合并params参数和query参数
## 1、在三级联动导航栏和search按钮中都需要向search页面跳转并传递参数，三级联动导航栏传递的是query参数，search传递的是params参数。若用户同时使用了这两个组件来搜索商品时，需要将两个组件的参数都传递给search组件，所以需要将两个组件传递的参数合并，不然会造成一个组件的参数替换另外一个组件的参数的现象。
## 2、合并参数的方法是在每一个组件发送参数前都判断一下当前路由中是否含有参数，如果有就将其保留下来并跟新的参数整合到一起重新发送

# mockjs模拟数据
## 1、服务器接口返回的数据只有商品分类菜单的分类数据，对于ListContainer组件与Floor组件服务器没有提供数据，需要通过mockjs插件来模拟数据
## 2、下载mockjs插件：npm i mockjs
## 3、使用mockjs插件
1. 在项目的src文件夹下创建一个mock文件夹，用来存放mockjs生成的假数据
2. 在mock文件夹中创建相应的json文件准备json数据,创建json文件时要注意格式化，不能留有空格，不然项目无法运行
3. 把mock数据需要的图片放置到public文件夹中
4. 创建mockServ.js文件，通过mockjs插件生成虚拟数据
5. 把mockServer.js文件在入口文件中引入(至少需要执行一次，才能模拟数据)

# 获取banner轮播图的数据
## 1、从上一步mock生成的接口中获取轮播图中的数据，进行展示
## 2、利用swiper插件生成轮播图(swiper版本5比较稳定)
    (1)下载swipper:npm i swiper@5.4.5
    (2)引入swiper包(js|css)，
    (3)编写页面中轮播图的结构
    (4)页面当中的DOM加载完毕后new Swiper实例，给轮播图添加动态效果
## 3、在轮播图组件中引入swiper的js库，而本项目中有多个轮播图，把swiper的样式库在main.js文件中引入更好，因为这样所有的轮播图都能享有样式了

## 4、给大轮播图添加动态效果时需要等到页面当中的DOM结构全都挂载完毕后才可以，如果在mounted函数里面创建swiper实例，由于轮播图的图片是通过接口获取的，有异步操作，所以组件挂载完毕后数据可能还没有获取完整，就会导致v-for遍历数据生成DOM结构还没有完成，从而破坏轮播图的效果，所以不能在mounted函数里面创建swiper实例。为了解决什么时候创建swiper实例的问题，需要使用watch+$nextTick技术
## 5、
        watch:{
            /*监听bannerList数据的变化，因为这条数据会发生变化：
            由空数组变为里面有4个元素,即如果监听函数执行，则证明数据仓库vuex中已经收集到了轮播图数据
            */
            bannerList:{
                handler(newValue,oldValue){
                    /*handler函数执行只能保证数据已经响应完毕了，还不能保证v-for已经解析完毕，
                    所以需要使用nextTick函数来保证。nextTick也是vue的生命周期函数之一，其在需要一个回调
                    函数作为参数，当下次(与初始化相比)DOM更新，循环(v-for)结束后，会将其输入的回调函数延时，
                    在修改完成数据才会调用其输入的回调函数
                    */
                
                    this.$nextTick(()=>{
                        //当该函数执行时，服务器的数据已经响应回本地了，v-for已执行完毕了，即轮播图的结构一定有了
                        //创建swiper实例，实现轮播图的动态效果
                        var mySwiper = new Swiper(".swiper-container",{
                            loop:true,//控制轮播图循环播放
                            autoplay:true,//控制轮播图是否自动播放
                            //配置分页器
                            pagination:{
                                el:".swiper-pagination",
                                clickable:"true",
                            },
                            //配置前进和后退按钮
                            navigation:{
                                nextEl:".swiper-button-next",
                                prevEl:".swiper-button-prev",
                            },
                        });

                    });
                },

            },
        },
## 6、$nextTick可以保证页面中的结构一定存在，经常和很多的插件(需要DOM存在才能执行的插件)一起使用

## 7、给两个小的轮播图设置动态效果时，可以将创建Swiper实例的代码写在mounted函数中，这是因为在大的轮播图里面是在大的轮播图所在的组件内部发送的请求获取数据从而动态渲染结构，即至少需要服务器的数据回来才能渲染好DOM结构。而在小的轮播图中组件的内部是没有发请求的，是在其父组件home组件中发请求获取的数据，小的轮播图的数据是其父组件通过props传递过来的，因此是在结构已经有了的情况下执行的monted

# 把首页中的轮播图拆分为一个共用的全局组件
## 1、拆分成公用全局组件的前提：结构、样式和行为几乎一致才可以
## 2、为了能够使得轮播图满足拆分成全局组件的条件，将小轮播图的创建swiper实例对象的代码也放在watch中，但是小轮播图中的数据是父组件给的，没有发生改变。所以需要配置监听属性时加上immediate配置项，不管数据有没有发生改变监听属性里面的handler函数都执行一次。
## 3、拆分成全局组件后，将其注册为全局组件后使用即可。若组件中的数据不同可以采用props属性修改数据










